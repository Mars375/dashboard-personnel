---
phase: 01-quick-wins-securite
plan: 02
type: execute
wave: 2
depends_on: []
files_modified:
  - server/routes/auth.ts
  - server/middleware/auth.ts
  - src/lib/auth/tokenMigration.ts
  - src/App.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tokens OAuth sont stockés en HttpOnly cookies via le proxy"
    - "Les tokens localStorage sont migrés automatiquement vers les cookies"
    - "Les tokens invalides sont nettoyés du localStorage après migration réussie"
    - "L'utilisateur voit un message de succès après migration"
  artifacts:
    - path: "server/routes/auth.ts"
      provides: "OAuth callback with HttpOnly cookie"
      exports: ["GET /api/auth/google", "GET /api/auth/callback"]
    - path: "server/middleware/auth.ts"
      provides: "Cookie extraction for proxy requests"
      exports: ["extractTokens()"]
    - path: "src/lib/auth/tokenMigration.ts"
      provides: "Token migration script with exponential backoff"
      exports: ["migrateTokens()"]
    - path: "src/App.tsx"
      provides: "Migration trigger on app load"
      contains: "useEffect with migrateTokens call"
  key_links:
    - from: "server/routes/auth.ts"
      to: "response.cookie()"
      via: "HttpOnly cookie setting in OAuth callback"
      pattern: "res\\.cookie\\('auth_tokens'.*httpOnly:\\s*true"
    - from: "src/lib/auth/tokenMigration.ts"
      to: "/api/auth/migrate"
      via: "POST request with legacy tokens"
      pattern: "fetch\\('/api/auth/migrate'"
    - from: "src/App.tsx"
      to: "tokenMigration.ts"
      via: "useEffect on mount"
      pattern: "useEffect\\(\\(\\) => \\{.*migrateTokens"
---

<objective>
Sécuriser les tokens OAuth en les stockant dans des cookies HttpOnly

Purpose: Protéger les tokens contre les attaques XSS en les déplaçant de localStorage vers des cookies HttpOnly inaccessibles à JavaScript
Output: Tokens stockés en HttpOnly cookies + migration automatique des tokens existants
</objective>

<execution_context>
@/home/orion/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/orion/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-quick-wins-securite/01-CONTEXT.md
@.planning/phases/01-quick-wins-securite/01-RESEARCH.md

# Existing OAuth Proxy
- server/routes/auth.ts contient les routes OAuth existantes
- Le proxy Express redirige vers Google/Microsoft/Notion OAuth

# Pattern from CONTEXT.md (Decisions)
- **Migration approach:** Hybrid — automatic token migration via backend, fallback to forced re-login
- **User communication:** Progressive — small notice on next login ("Sécurité améliorée !")
- **Migration failures:** Retry silently with exponential backoff (3 attempts max)
- **Timing:** Immediate migration on first app load after deployment

# Dependencies from Plan 01
- None required (this plan is independent)
</context>

<tasks>

<task type="auto">
  <name>Créer le middleware d'extraction de tokens depuis les cookies</name>
  <files>server/middleware/auth.ts</files>
  <action>
    Créer le fichier server/middleware/auth.ts avec la fonction extractTokens:

    ```typescript
    import { Request } from 'express';
    import cookie from 'cookie';

    export interface AuthTokens {
      access_token?: string;
      refresh_token?: string;
      provider?: string;
    }

    export function extractTokens(req: Request): AuthTokens {
      const cookieHeader = req.headers.cookie;
      if (!cookieHeader) {
        return {};
      }

      const cookies = cookie.parse(cookieHeader);
      const authData = cookies.auth_tokens;

      if (!authData) {
        return {};
      }

      try {
        return JSON.parse(authData);
      } catch {
        return {};
      }
    }
    ```

    Installer le package cookie si nécessaire:
    ```bash
    pnpm add cookie
    ```
  </action>
  <verify>
    Le fichier server/middleware/auth.ts existe et exporte extractTokens:
    ```bash
    grep -q "export function extractTokens" server/middleware/auth.ts && echo "OK"
    ```
  </verify>
  <done>
    Middleware créé pour extraire les tokens depuis les cookies HttpOnly
  </done>
</task>

<task type="auto">
  <name>Modifier les routes OAuth pour définir des cookies HttpOnly</name>
  <files>server/routes/auth.ts</files>
  <action>
    Pour chaque fournisseur OAuth (google, microsoft, notion) dans server/routes/auth.ts:

    1. Dans la route callback (ex: /api/auth/callback), après avoir obtenu les tokens:

    Remplacer tout stockage localStorage par un cookie HttpOnly:

    ```typescript
    import { extractTokens } from '../middleware/auth.js';

    router.get('/google/callback', async (req, res) => {
      const { code } = req.query;

      // Échange du code contre des tokens (code existant)
      const tokens = await exchangeCodeForTokens(code);

      // Stocker dans un cookie HttpOnly au lieu de renvoyer au frontend pour localStorage
      res.cookie('auth_tokens', JSON.stringify({
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        provider: 'google'
      }), {
        httpOnly: true,    // Inaccessible à JavaScript
        secure: process.env.NODE_ENV === 'production',  // HTTPS only en prod
        sameSite: 'strict', // Protection CSRF
        maxAge: 7 * 24 * 60 * 60 * 1000, // 7 jours
        path: '/'
      });

      // Rediriger vers le frontend
      res.redirect(process.env.FRONTEND_URL || 'http://localhost:5173/dashboard');
    });
    ```

    2. Créer une nouvelle route pour la migration des tokens existants:

    ```typescript
    router.post('/migrate', async (req, res) => {
      const { provider, tokens } = req.body;

      if (!provider || !tokens) {
        return res.status(400).json({ error: 'Missing provider or tokens' });
      }

      // Stocker les tokens migrés dans un cookie HttpOnly
      res.cookie('auth_tokens', JSON.stringify({
        access_token: tokens.access_token,
        refresh_token: tokens.refresh_token,
        provider
      }), {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 7 * 24 * 60 * 60 * 1000,
        path: '/'
      });

      res.json({ success: true, message: 'Tokens migrated successfully' });
    });
    ```
  </action>
  <verify>
    Vérifier que les callbacks OAuth définissent des cookies HttpOnly:
    ```bash
    grep -A2 "res.cookie" server/routes/auth.ts | grep "httpOnly.*true"
    ```

    Vérifier que la route /migrate existe:
    ```bash
    grep -q "router.post('/migrate'" server/routes/auth.ts && echo "OK"
    ```
  </verify>
  <done>
    Les routes OAuth stockent les tokens dans des cookies HttpOnly
  </done>
</task>

<task type="auto">
  <name>Créer le script de migration des tokens avec retry exponentiel</name>
  <files>src/lib/auth/tokenMigration.ts</files>
  <action>
    Créer le fichier src/lib/auth/tokenMigration.ts:

    ```typescript
    import { logger } from '@/lib/logger';

    interface LegacyTokens {
      access_token: string;
      refresh_token?: string;
    }

    async function migrateWithRetry(
      provider: string,
      tokens: LegacyTokens
    ): Promise<boolean> {
      const maxAttempts = 3;
      let attempt = 0;

      while (attempt < maxAttempts) {
        try {
          const response = await fetch('/api/auth/migrate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ provider, tokens }),
          });

          if (response.ok) {
            return true;
          }

          attempt++;
          if (attempt >= maxAttempts) {
            logger.error(`Migration failed after ${maxAttempts} attempts for ${provider}`);
            return false;
          }

          // Exponential backoff: 1s, 2s, 4s
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        } catch (error) {
          logger.error(`Migration attempt ${attempt + 1} failed for ${provider}:`, error);
          attempt++;
          if (attempt >= maxAttempts) {
            return false;
          }
          const delay = Math.pow(2, attempt) * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      return false;
    }

    export async function migrateTokens(): Promise<boolean> {
      const providers = ['google', 'microsoft', 'notion'];
      let anyMigrated = false;

      for (const provider of providers) {
        const tokenKey = `${provider}_tokens`;
        const userKey = `${provider}_user`;
        const legacyTokens = localStorage.getItem(tokenKey);

        if (!legacyTokens) {
          continue;
        }

        try {
          const tokens = JSON.parse(legacyTokens);
          const success = await migrateWithRetry(provider, tokens);

          if (success) {
            localStorage.removeItem(tokenKey);
            localStorage.removeItem(userKey);
            logger.info(`Successfully migrated ${provider} tokens to cookies`);
            anyMigrated = true;
          }
        } catch (error) {
          logger.error(`Failed to migrate ${provider} tokens:`, error);
        }
      }

      return anyMigrated;
    }
    ```
  </action>
  <verify>
    Le fichier existe et exporte migrateTokens:
    ```bash
    grep -q "export async function migrateTokens" src/lib/auth/tokenMigration.ts && echo "OK"
    ```

    Vérifier la logique de retry exponentiel:
    ```bash
    grep -q "Math.pow(2, attempt)" src/lib/auth/tokenMigration.ts && echo "OK"
    ```
  </verify>
  <done>
    Script de migration créé avec retry exponentiel et nettoyage du localStorage
  </done>
</task>

<task type="auto">
  <name>Déclencher la migration au chargement de l'application et afficher un message</name>
  <files>src/App.tsx</files>
  <action>
    Dans src/App.tsx:

    1. Importer le module de migration:
    ```typescript
    import { useEffect } from 'react';
    import { migrateTokens } from '@/lib/auth/tokenMigration';
    import { toast } from 'sonner';
    ```

    2. Ajouter un useEffect pour déclencher la migration au montage:
    ```typescript
    useEffect(() => {
      const migrationShown = sessionStorage.getItem('migration_notice_shown');

      migrateTokens().then((anyMigrated) => {
        if (anyMigrated && !migrationShown) {
          toast.success("Sécurité améliorée ! Votre session a été préservée.", {
            duration: 5000,
            position: 'bottom-right',
          });
          sessionStorage.setItem('migration_notice_shown', 'true');
        }
      });
    }, []);
    ```

    Ne déclencher la migration qu'une seule fois par session (stocker un flag dans sessionStorage).
  </action>
  <verify>
    Vérifier que App.tsx déclenche la migration:
    ```bash
    grep -q "migrateTokens()" src/App.tsx && echo "OK"
    ```

    Vérifier que le message de succès utilise toast:
    ```bash
    grep -A2 "migrateTokens" src/App.tsx | grep "toast.success"
    ```
  </verify>
  <done>
    La migration est déclenchée automatiquement au chargement de l'app avec un message utilisateur
  </done>
</task>

</tasks>

<verification>
- [ ] Le middleware extractTokens peut lire les cookies HttpOnly
- [ ] Les routes OAuth callback définissent des cookies HttpOnly avec les bons flags
- [ ] La route /api/auth/migrate existe et accepte les tokens legacy
- [ ] Le script de migration implémente un retry avec backoff exponentiel (1s, 2s, 4s)
- [ ] localStorage est nettoyé après une migration réussie
- [ ] Un toast s'affiche après migration (une seule fois par session)
- [ ] Le message est en français: "Sécurité améliorée !"
</verification>

<success_criteria>
**Observable (E2E flow):**
1. Premier lancement après deployment:
   - Tokens existent dans localStorage
   - Migration automatique se lance
   - Cookies HttpOnly créés
   - localStorage vidé
   - Toast "Sécurité améliorée !" s'affiche

2. Login ultérieur:
   - OAuth callback crée directement le cookie HttpOnly
   - Plus aucun token dans localStorage

**Measurable:**
- 0 token OAuth dans localStorage après migration
- Cookies HttpOnly présents avec httpOnly=true
- Migration réussie = toast affiché
- Échec migration = fallback à re-login naturel
</success_criteria>

<output>
After completion, create `.planning/phases/01-quick-wins-securite/01-02-SUMMARY.md`
</output>
