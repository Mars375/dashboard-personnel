---
phase: 01-quick-wins-securite
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - package.json
  - src/lib/validations/auth.ts
  - src/lib/validations/todo.ts
  - src/lib/validations/settings.ts
  - src/components/LoginForm.tsx
  - src/widgets/Todo/TodoAddForm.tsx
  - src/components/SettingsForm.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Les formulaires utilisent Zod pour la validation des données"
    - "La validation est progressive (on submit d'abord, puis on change)"
    - "Les erreurs s'affichent inline sous chaque champ invalide"
    - "Le ton des messages est amical mais précis (français)"
    - "Les formulaires critiques bloquent la soumission si invalide"
  artifacts:
    - path: "package.json"
      provides: "Dependencies for form validation"
      contains: "zod, react-hook-form, @hookform/resolvers"
    - path: "src/lib/validations/*.ts"
      provides: "Zod schemas for form validation"
      exports: ["authSchema", "todoSchema", "settingsSchema"]
    - path: "src/components/*/Form.tsx"
      provides: "React Hook Form integration with Zod"
      contains: "useForm with zodResolver"
  key_links:
    - from: "src/lib/validations/*.ts"
      to: "react-hook-form"
      via: "zodResolver integration"
      pattern: "zodResolver\\(.*Schema\\)"
    - from: "src/components/*/Form.tsx"
      to: "Zod schemas"
      via: "import from @/lib/validations"
      pattern: "import.*from '@/lib/validations"
---

<objective>
Implémenter la validation des formulaires avec Zod et React Hook Form

Purpose: Valider les entrées utilisateur côté client avec des schémas typés et des messages d'erreur amicaux
Output: Formulaires validés avec Zod, erreurs affichées inline, validation progressive
</objective>

<execution_context>
@/home/orion/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/orion/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-quick-wins-securite/01-CONTEXT.md
@.planning/phases/01-quick-wins-securite/01-RESEARCH.md

# Existing Forms
- src/components/LoginForm.tsx (formulaire de connexion)
- src/widgets/Todo/TodoAddForm.tsx (ajout de todos)
- src/components/SettingsForm.tsx (paramètres, si existe)

# Pattern from CONTEXT.md (Decisions)
- **Validation timing:** Progressive — on submit first, then on change after first validation attempt
- **Error display:** Inline errors directly below each invalid field (no toast spam or summary component)
- **Submission behavior:** Context-aware based on form criticality
  - Critical forms (auth): Block submission completely
  - Standard forms (todos, settings): Allow submit with warnings
- **Error tone:** Friendly but precise (e.g., "Format d'email invalide")

# Dependencies from Other Plans
- None required (this plan is independent)
</context>

<tasks>

<task type="auto">
  <name>Installer les dépendances pour la validation de formulaires</name>
  <files>package.json</files>
  <action>
    Installer les packages nécessaires:
    ```bash
    pnpm add zod react-hook-form @hookform/resolvers
    ```

    Ces packages fournissent:
    - zod: Validation de schémas avec TypeScript
    - react-hook-form: Gestion d'état de formulaires performante
    - @hookform/resolvers: Intégration de zod avec react-hook-form
  </action>
  <verify>
    Les packages sont installés:
    ```bash
    grep -E '"(zod|react-hook-form|@hookform/resolvers)"' package.json
    ```
  </verify>
  <done>
    Dépendances de validation installées
  </done>
</task>

<task type="auto">
  <name>Créer les schémas de validation Zod</name>
  <files>src/lib/validations/auth.ts</files>
  <action>
    Créer le fichier src/lib/validations/auth.ts pour les formulaires d'authentification:

    ```typescript
    import { z } from 'zod';

    // Messages d'erreur communs (français, amical mais précis)
    const commonErrors = {
      required: (field: string) => `${field} est requis`,
      email: "Format d'email invalide",
      minLength: (min: number) => `Au moins ${min} caractères requis`,
      password: "Doit contenir une majuscule, une minuscule, un chiffre",
    };

    export const loginSchema = z.object({
      email: z
        .string()
        .min(1, { message: commonErrors.required("Email") })
        .email({ message: commonErrors.email }),
      password: z
        .string()
        .min(1, { message: commonErrors.required("Mot de passe") }),
    });

    export const registerSchema = z.object({
      email: z
        .string()
        .min(1, { message: commonErrors.required("Email") })
        .email({ message: commonErrors.email }),
      password: z
        .string()
        .min(8, { message: commonErrors.minLength(8) })
        .regex(/[A-Z]/, { message: "Doit contenir une majuscule" })
        .regex(/[a-z]/, { message: "Doit contenir une minuscule" })
        .regex(/[0-9]/, { message: "Doit contenir un chiffre" }),
      confirmPassword: z.string(),
    }).refine((data) => data.password === data.confirmPassword, {
      message: "Les mots de passe ne correspondent pas",
      path: ["confirmPassword"],
    });

    export type LoginFormData = z.infer<typeof loginSchema>;
    export type RegisterFormData = z.infer<typeof registerSchema>;
    ```

    Les messages sont en français, amicaux ("Format d'email invalide" plutôt que "Invalid email format"), et précis sur ce qui doit être corrigé.
  </action>
  <verify>
    Le fichier existe et exporte les schémas:
    ```bash
    grep -q "export const loginSchema" src/lib/validations/auth.ts && echo "OK"
    grep -q "export const registerSchema" src/lib/validations/auth.ts && echo "OK"
    ```
  </verify>
  <done>
    Schémas de validation pour l'authentification créés avec des messages français amicaux
  </done>
</task>

<task type="auto">
  <name>Créer les schémas de validation pour les todos</name>
  <files>src/lib/validations/todo.ts</files>
  <action>
    Créer le fichier src/lib/validations/todo.ts:

    ```typescript
    import { z } from 'zod';

    export const todoSchema = z.object({
      title: z
        .string()
        .min(1, { message: "Le titre est requis" })
        .max(200, { message: "Le titre ne peut pas dépasser 200 caractères" }),
      description: z.string().optional(),
      dueDate: z.string().refine(
        (val) => !val || !isNaN(Date.parse(val)),
        { message: "Date invalide" }
      ).optional(),
      priority: z.enum(['low', 'medium', 'high']).optional(),
    });

    export type TodoFormData = z.infer<typeof todoSchema>;
    ```

    Pour les todos (forme standard), on autorise la soumission avec des avertissements si certains champs sont invalides (selon les décisions CONTEXT.md).
  </action>
  <verify>
    Le fichier existe et exporte le schéma:
    ```bash
    grep -q "export const todoSchema" src/lib/validations/todo.ts && echo "OK"
    ```
  </verify>
  <done>
    Schéma de validation pour les todos créé
  </done>
</task>

<task type="auto">
  <name>Mettre à jour LoginForm avec validation Zod</name>
  <files>src/components/LoginForm.tsx</files>
  <action>
    Mettre à jour src/components/LoginForm.tsx:

    ```typescript
    import { useForm } from 'react-hook-form';
    import { zodResolver } from '@hookform/resolvers/zod';
    import { loginSchema, LoginFormData } from '@/lib/validations/auth';

    export function LoginForm() {
      const [hasSubmitted, setHasSubmitted] = useState(false);

      const {
        register,
        handleSubmit,
        trigger,
        formState: { errors, isSubmitting },
        setError,
      } = useForm<LoginFormData>({
        resolver: zodResolver(loginSchema),
        mode: hasSubmitted ? 'onChange' : 'onSubmit', // Validation progressive
      });

      const handleChange = (fieldName: string) => {
        if (hasSubmitted) {
          trigger(fieldName); // Valider ce champ uniquement
        }
      };

      const onSubmit = async (data: LoginFormData) => {
        setHasSubmitted(true);

        try {
          await login(data);
          toast.success('Connexion réussie');
        } catch (error) {
          if (error instanceof AuthError) {
            setError('root', { message: error.message });
          }
        }
      };

      return (
        <form onSubmit={handleSubmit(onSubmit)} noValidate>
          <div className="space-y-4">
            <div>
              <label htmlFor="email">Email</label>
              <input
                id="email"
                type="email"
                {...register('email', {
                  onChange: () => handleChange('email'),
                })}
                aria-invalid={!!errors.email}
                aria-describedby={errors.email ? 'email-error' : undefined}
                className="w-full px-3 py-2 border rounded"
              />
              {errors.email && (
                <span id="email-error" className="text-sm text-red-600">
                  {errors.email.message}
                </span>
              )}
            </div>

            <div>
              <label htmlFor="password">Mot de passe</label>
              <input
                id="password"
                type="password"
                {...register('password', {
                  onChange: () => handleChange('password'),
                })}
                aria-invalid={!!errors.password}
                aria-describedby={errors.password ? 'password-error' : undefined}
                className="w-full px-3 py-2 border rounded"
              />
              {errors.password && (
                <span id="password-error" className="text-sm text-red-600">
                  {errors.password.message}
                </span>
              )}
            </div>

            {errors.root && (
              <div className="text-sm text-red-600" role="alert">
                {errors.root.message}
              </div>
            )}

            <button
              type="submit"
              disabled={isSubmitting}
              className="w-full px-4 py-2 bg-blue-600 text-white rounded disabled:opacity-50"
            >
              {isSubmitting ? 'Connexion...' : 'Connexion'}
            </button>
          </div>
        </form>
      );
    }
    ```

    Points clés:
    - Mode de validation: 'onSubmit' d'abord, puis 'onChange' après first submit
    - Erreurs inline sous chaque champ (pas de toast)
    - aria-invalid et aria-describedby pour l'accessibilité
    - Formulaire critique: bloquer la soumission si invalide (comportement par défaut de handleSubmit)
  </action>
  <verify>
    Vérifier que LoginForm utilise Zod:
    ```bash
    grep "zodResolver" src/components/LoginForm.tsx
    grep "loginSchema" src/components/LoginForm.tsx
    ```

    Vérifier la validation progressive:
    ```bash
    grep "hasSubmitted.*onChange.*onSubmit" src/components/LoginForm.tsx
    ```
  </verify>
  <done>
    LoginForm mis à jour avec validation Zod, erreurs inline, validation progressive
  </done>
</task>

<task type="auto">
  <name>Mettre à jour TodoAddForm avec validation Zod</name>
  <files>src/widgets/Todo/TodoAddForm.tsx</files>
  <action>
    Mettre à jour src/widgets/Todo/TodoAddForm.tsx:

    ```typescript
    import { useForm } from 'react-hook-form';
    import { zodResolver } from '@hookform/resolvers/zod';
    import { todoSchema, TodoFormData } from '@/lib/validations/todo';

    export function TodoAddForm() {
      const [hasSubmitted, setHasSubmitted] = useState(false);

      const {
        register,
        handleSubmit,
        trigger,
        formState: { errors },
      } = useForm<TodoFormData>({
        resolver: zodResolver(todoSchema),
        mode: hasSubmitted ? 'onChange' : 'onSubmit',
      });

      const handleChange = (fieldName: string) => {
        if (hasSubmitted) {
          trigger(fieldName);
        }
      };

      const onSubmit = async (data: TodoFormData) => {
        setHasSubmitted(true);

        // Pour les todos (forme standard), autoriser la soumission avec des avertissements
        const result = todoSchema.safeParse(data);
        if (!result.success) {
          toast.warning('Certaines données sont invalides mais ont été enregistrées');
        }

        await addTodo(data);
      };

      return (
        <form onSubmit={handleSubmit(onSubmit)} noValidate>
          <div className="space-y-3">
            <div>
              <input
                placeholder="Nouvelle tâche..."
                {...register('title', {
                  onChange: () => handleChange('title'),
                })}
                aria-invalid={!!errors.title}
                className="w-full px-3 py-2 border rounded"
              />
              {errors.title && (
                <span className="text-sm text-orange-600">
                  {errors.title.message}
                </span>
              )}
            </div>

            <button
              type="submit"
              className="px-4 py-2 bg-green-600 text-white rounded"
            >
              Ajouter
            </button>
          </div>
        </form>
      );
    }
    ```

    Note: Pour les todos (forme standard), on autorise la soumission même avec des erreurs de validation (selon les décisions CONTEXT.md), mais on affiche un toast d'avertissement.
  </action>
  <verify>
    Vérifier que TodoAddForm utilise Zod:
    ```bash
    grep "zodResolver" src/widgets/Todo/TodoAddForm.tsx
    grep "todoSchema" src/widgets/Todo/TodoAddForm.tsx
    ```
  </verify>
  <done>
    TodoAddForm mis à jour avec validation Zod, soumission autorisée avec avertissement
  </done>
</task>

</tasks>

<verification>
- [ ] Les dépendances zod, react-hook-form, @hookform/resolvers sont installées
- [ ] Les schémas loginSchema, registerSchema, todoSchema sont créés dans src/lib/validations/
- [ ] Les messages d'erreur sont en français, amicaux mais précis
- [ ] LoginForm utilise la validation progressive (onSubmit → onChange)
- [ ] TodoAddForm utilise la validation context-aware (autoriser avec warning)
- [ ] Les erreurs s'affichent inline sous chaque champ (pas de toast)
- [ ] aria-invalid et aria-describedby sont utilisés pour l'accessibilité
- [ ] Les formulaires critiques bloquent la soumission si invalide
</verification>

<success_criteria>
**Observable:**
1. Formulaire de login:
   - Saisie d'email invalide → pas d'erreur pendant la saisie
   - Soumettre → erreur inline s'affiche
   - Corriger l'email → erreur disparaît immédiatement
   - Submit valide → connexion réussie

2. Formulaire todo:
   - Saisie de titre vide → pas d'erreur pendant la saisie
   - Soumettre → toast "Certaines données sont invalides mais ont été enregistrées"
   - Todo quand même ajouté (comportement standard pour formes non-critiques)

**Measurable:**
- 3 schémas Zod créés (login, register, todo)
- 2 formulaires mis à jour (Login, TodoAdd)
- 0 toast d'erreur de validation (erreurs inline uniquement)
- 100% des formulaires utilisent Zod
</success_criteria>

<output>
After completion, create `.planning/phases/01-quick-wins-securite/01-04-SUMMARY.md`
</output>
